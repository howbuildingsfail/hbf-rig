<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microphone Ellipse Animation</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>-->
    <script src="./p5/p5.js"></script>
    <script src="./p5/addons/p5.sound.min.js"></script>
    <script>
      
    	//lenia params
			let params = {
				mu_k:    4.0,//4.0, range 2 to 12
				sigma_k: 0.125, //was 1.0
				w_k:     0.022,//0.022,
				mu_g:    0.6,
				sigma_g: 0.15,
				c_rep:   0.125,//1.0,
				dt:      0.1,
				scscale: 100 //75 - this is calculated per frame so no matter! 
			};

			let point_n = 450;//90;
			let points;
			let fields;
			let steps_per_frame; // Adjust this based on desired speed
			let randomCol;

      //mic params
      let mic;
      let fft;
      let particles = [];

      function setup() {
      
      	//lenia section
				//createCanvas(1200, 800);
        createCanvas(windowWidth, windowHeight);
        //createCanvas(400, 400);
				points = init(new Float32Array(point_n * 2));
				fields = {
					R_val: new Float32Array(point_n),
					U_val: new Float32Array(point_n),
					R_grad: new Float32Array(point_n * 2),
					U_grad: new Float32Array(point_n * 2)
				};

				colorMode(RGB, 200, 200, 200, 200);
				noStroke();

				steps_per_frame = 30;//int(random(1, 10));

				randomCol = random();
				console.log(randomCol);
      
      	////////////////////////////////////////////////
        //mic section
        mic = new p5.AudioIn();
        mic.start();
  	  
  			//getAudioContext().resume();
  	  
        fft = new p5.FFT(0.8, 128);//64
        fft.setInput(mic);

        //for (let i = 0; i < 100; i++) {
        //  particles.push(new Particle());
        //}
      }

			//Click in window to connect audio
			function touchStarted() {
				getAudioContext().resume();
			}

      function draw() {
        background(0);

        let spectrum = fft.analyze();
        let amp = fft.getEnergy("bass");

				//console.log("bass amp: ",amp)	
				
				params.sigma_k = 0.125 + (fft.getEnergy("mid")/200);
				params.c_rep =  1 - (fft.getEnergy("highMid")/300);
				params.scscale = 30 + (255-fft.getEnergy("lowMid"))/3;
	
        //for (let particle of particles) {
        //  particle.update(amp*2);
        //  particle.show();
        //}
          
        for (let i = 0; i < steps_per_frame; ++i) step();
				background(0, 40);
				
				halfw = width/2;
				halfh = height/2;
				
				translate(halfw, halfh);
				
				currentscale = width / params.scscale;
				xlim = 0.5 * width/currentscale;
				ylim = 0.5 * height/currentscale;
				
				console.log(currentscale);
				
				scale(currentscale);//50.0);
				strokeWeight(0.1);

				for (let i = 0; i < point_n; ++i) {
				
				  ii = i * 2;
				  jj = i * 2 + 1;
					//return points outside boundary to zero...
					points[ii] = points[ii] >=  xlim  ? -xlim  : points[ii];
					points[ii] = points[ii] <= -xlim  ? -xlim  : points[ii]+0.05;//random(0.1,0.15);
					//
					points[jj] = points[jj] >=  ylim  ? 0  : points[jj];
					points[jj] = points[jj] <= -ylim  ? 0  : points[jj];
				
				
					let x = points[i * 2], y = points[i * 2 + 1];
					
					//Handle screen wrapping
					//x = x > halfw  ? x-width  : (x< -halfw ? x+width  : x );
					//y = y > halfh  ? y-height : (y< -halfh ? y+height : y );
					
					//debugging
					
								
					
					
					let r = params.c_rep / (fields.R_val[i] * 5.0);
					
					if(randomCol < 0.3){
						fill((i)/point_n* 200, 70, 100, 162);
					} else if(0.3 <= randomCol && randomCol < 0.6) {
						fill(90, 80, (i)/point_n* 200, 162);
					} else {
						fill(20, (i)/point_n* 200, 180, 162);
					}
					
					ellipse(x, y, r * 2*amp/70, r * 2*amp/70);
					//quad(x,y,
					//     x+(r*2*Math.random()),y,
					//     x+(r*2*Math.random()),y+(r*2*Math.random()),
					//     x,y+(r*2*Math.random())
					//    )
					
										
					
				}
  				
  			//debugging boundaries	
  			//square(-10/currentscale, -10/currentscale, 20/currentscale);
  			//square(0.45*width/currentscale,0.45*height/currentscale,20/currentscale);
  			//square(0.45*width/currentscale,0.45*height/currentscale,20/currentscale);
  			
      }

			function init(points) {
				for (let i = 0; i < point_n; ++i) {
					points[i * 2] = (Math.random() - 0.5) * 18;//12;
					points[i * 2 + 1] = (Math.random() - 0.5) * 12;//12;
				}
				return points;
			}

			function add_xy(a, i, x, y, c) {
				a[i * 2] += x * c;
				a[i * 2 + 1] += y * c;
			}

			function compute_fields() {
				const { R_val, U_val, R_grad, U_grad } = fields;
				const { c_rep, mu_k, sigma_k, w_k } = params;
				R_val.fill(repulsion_f(0.0, c_rep)[0]);
				U_val.fill(peak_f(0.0, mu_k, sigma_k, w_k)[0]);
				R_grad.fill(0);
				U_grad.fill(0);

				for (let i = 0; i < point_n - 1; ++i) {
					for (let j = i + 1; j < point_n; ++j) {
						let rx = points[i * 2] - points[j * 2];
						let ry = points[i * 2 + 1] - points[j * 2 + 1];
						const r = Math.sqrt(rx * rx + ry * ry) + 1e-20;
						rx /= r;
						ry /= r;

						if (r < 1.0) {
						  const [R, dR] = repulsion_f(r, c_rep);
						  add_xy(R_grad, i, rx, ry, dR);
						  add_xy(R_grad, j, rx, ry, -dR);
						  R_val[i] += R;
						  R_val[j] += R;
						}
						const [K, dK] = peak_f(r, mu_k, sigma_k, w_k);
						add_xy(U_grad, i, rx, ry, dK);
						add_xy(U_grad, j, rx, ry, -dK);
						U_val[i] += K;
						U_val[j] += K;
					}
				}
			}

			function repulsion_f(x, c_rep) {
				const t = Math.max(1.0 - x, 0.0);
				return [0.5 * c_rep * t * t, -c_rep * t];
			}

			function fast_exp(x) {
				let t = 1.0 + x / 32.0;
				t *= t;
				t *= t;
				t *= t;
				t *= t;
				t *= t;
				return t;
			}

			function peak_f(x, mu, sigma, w = 1.0) {
				const t = (x - mu) / sigma;
				const y = w / fast_exp(t * t);
				return [y, -2.0 * t * y / sigma];
			}

			function step() {
				const { R_val, U_val, R_grad, U_grad } = fields;
				const { mu_g, sigma_g, dt } = params;
				compute_fields();
				let total_E = 0.0;
				for (let i = 0; i < point_n; ++i) {
					const [G, dG] = peak_f(U_val[i], mu_g, sigma_g);
					const vx = dG * U_grad[i * 2] - R_grad[i * 2];
					const vy = dG * U_grad[i * 2 + 1] - R_grad[i * 2 + 1];
					add_xy(points, i, vx, vy, dt);
					total_E += R_val[i] - G;
				}
				return total_E / point_n;
			}
    </script>
  </body>
</html>
